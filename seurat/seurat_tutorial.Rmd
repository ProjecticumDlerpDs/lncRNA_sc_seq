---
title: "seurat_tutorial"
output: pdf_document
date: "2025-09-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if (!tinytex::is_tinytex()) {
  tinytex::install_tinytex()
}
```

## seurat tutorial
Voor het project gaan we analyses uitvoeren met Seurat. Om kennis te maken met het progamma wordt er een [tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial) uitgevoerd van Seurat.
Seurat is een pakket in Rstudio voor de analyse van singel-cell RNA sequencing (scRNA-seq) data. Seurat beid veel functies aan voor het verwerken, visualiseren en het interpreteren van de genexpressie op celniveau.
In de Seurat tutorial worden de volgende stappen doorlopen
- inladen van de data
- QC van de data en selecteren van de cellen voor vervolganalyse
- normaliseren van de data en het schalen van de data
- Dimensionaliteitsreductie met PCA
- clusteren van de genen
- Visualisatie van resultaten in overzichtelijke plots
- Identificatie van markers die specifieke celtypen onderscheiden

### doel
Het doel is om vertrouwd te raken met de verschillende functies van Seurat en te leren hoe ik deze functies kan gebruiken om de RNA-seq data te verwerken, visualiseren en analyseren.

### hypothese
Er wordt verwacht dat de analyse met Seurat verschillende celtypen binnen de dataset kan clusteren en idetificeren en dat deze celtypen duidelijke verschillen in genexpressie laten zien.

### het inladen van de data
De data wordt inladen als een object. Hierna wordt er een extra collom aangemaakt waarbij het pecentage mitochondriaal RNA berekend wordt. cellen die lage kwaliteit hebben vertonen vaak een hoog percentage mitochondriaal RNA. Om dit te visualiseren wordt er een vulcanoplot gemaakt. In de plot is nFeature_RNA: Hierbij wordt er gekeken hoe rijk een cel is in termen van expressie, nCount_RNA: Hier wordt de som van aantal genen weergeven en percent.mt: hierbij wordt weergeven hoeveel mitochondriaal RNA een cel bezit. 


```{r loading the library, include=FALSE, echo=FALSE}
#laad de volgende pakketen in. 
library(dplyr)
library(Seurat)
library(patchwork)
```

```{r loading dataset, include=FALSE}
# data inladen als een object. 
pbmc.data <- Read10X(data.dir = "~/lncRNA_sc_splice/raw_data/hg19/")
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```

```{r pre-procesing, warning=FALSE, results='hide', echo=TRUE,echo=FALSE}
# extra collum aanmaken waar het pecentage mitochondriaal RNA berekend wordt. cellen die lage kwaliteit hebben vertonen vaak een hoog percentage mitochondriaal RNA. extra colom wordt gemaakt met [[]]

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
head(pbmc, 5)

# visulaiseren van de data. dit kan gedaan worden in een violin plot. ncol staat voor de nummer van collomen. 
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

met een featurescatter kan er gevisulaiseerd worden wat de relatie is tussen verschillende features. hierbij wordt weergeven de nCount_RNA tegen de percent.mt en in plot 2 wordt nCount_RNA vergeleken tegenover nFeature_RNA. 

```{r pre-procesing visueel maken, warning=FALSE, results='hide', echo=TRUE,echo=FALSE}
# met een featurescatter kan er gevisulaiseerd worden wat de relatie is tussen verschillende features.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 | plot2

# de cellen worden gefilterd op feature count van meer dan 2500 of minder dan 200. Er word ook gefilterd op minder dan 5% mitochondriaal pecentage
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
head(pbmc, 5)
```

De cellen worden gefilterd op feature count van meer dan 2500 of minder dan 200 features hebben. Er word ook gefilterd op minder dan 5% mitochondriaal pecentage. 

### normaliseren van de data
het normaliseren van de data wordt gedaan door middel van de log methode. deze functie staat standaard op 10.000 ingesteld. 

```{r normaliseren van de data, echo=FALSE, message=FALSE}
# variabele aanmaken waarin de data genormaliseerd is. 
pbmc <- NormalizeData(pbmc)
```

### feature selectie van de data
De data moet geselecteerd worden op genen die de meeste variabiliteit tonen. Dit zorgt ervoor dat bij verdere analyses er gefocused wordt op genen die variabel van elkaar zijn. Deze functie staat standaard ingesteld op 2000 features per dataset. De data wordt weergeven in een VariableFeaturePlot. In de plot staan de top 10 meest variabele genen weergeven. De labels geven de namen van de genen aan in het plot. 

```{r feature selectie van de data, warning=FALSE, echo=FALSE, message=FALSE}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

### schalen van de data
De functie zorgt ervoor dat de data vergelijkbaar wordt op de schaal en het gemiddelde. Dit zorgt ervoor dat de data beter verwerkt wordt bij verdere analyse zoals bij de PCA. Hierdoor wordt voorkomen dat genen die veel tot expressie komen niet overheersen. 

```{r scaling van de data, echo=FALSE, message=FALSE}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

Bij een PCA analyse wordt de grote hoeveelheid data vereenvoudigt. Dit wordt gedaan door te kijken welke De data kan ook in grafieken worden weergeven voor een vergemakkelijkeren weergaven. hieronder worden de eerse 5 PC's weergeven met daarin 5 features.

```{r PCA, message=FALSE, echo=FALSE, warning=FALSE}
# bij de eerste stap maakt Seurat een lijst voor de meest positieve en negatieve genen ten opzichte van de rest van de dataset. 
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))

# printen van de eerste 5 PC met elk 5 features.
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
```

De data kan ook gevisualiseerd worden in een 2D plot. Hierin worden de eerste twee dimenties weergeven. De top genen worden weergeven. 

```{r PCA 2D visualisatie, message=FALSE, echo=FALSE, warning=FALSE}
# het visulaizeren van 2D. 
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
```

De data kan ook worden weergeven in een dimplot. Een dimplot is een plot waar alle cellen zijn eigen puntje hebben. PC1 en PC2 zijn tegenover elkaar uitgezet.

```{r PCA dimplot, message=FALSE, echo=FALSE, warning=FALSE}
# dimplot is een plot waar alle puntjes cellen zijn. PC1 en PC2 zijn tegenover elkaar uitgezet. 
DimPlot(pbmc, reduction = "pca") + NoLegend()
```

Een heatmap wordt gebruikt om te kijken welke onderdelen de grootste variatie van elkaar hebben. Dit kan ook gebruikt worden om te bepalen welke PC's er meegenomen worden voor verdere analyse downstream. Door cellen op een getal in te stellen, worden de meest extreme cellen aan beide uiteinden van het spectrum weergegeven, wat het plotten van grote datasets aanzienlijk versnelt. 

```{r PCA heatmap, message=FALSE, echo=FALSE, warning=FALSE}
# heatmap wordt gebruikt om te kijken welke onderdelen de grootste variatie van elkaar hebben. 
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)

```

Clusters worden gebaseerd op de PCA waardes. Dit zijn correlaties tussen cellen die met de genexpressie op elkaar lijken. om te bepalen hoeveel van de PC's we mee nemen wordt er een ElbowPlot van de PC's gemaakt. In de plot wordt weergeven hoeveel variatie de PC's bezitten.

```{r dimentie bepalen van dataset, echo=FALSE}
# elbowplot laat de verschillende dimenties zien. Hiermee kan je kiezen hoeveel dimenties je mee wilt nemen voor volgende analyses. 
ElbowPlot(pbmc)
# aan de hand van de grafiek worden de eerste 10 PC's mee genomen. 
```

Aan de hand van de grafiek is er voor gekozen om de eerste 10 PC's mee te nemen met de verdere dataverwerking. 
De data moet worden geclusterd. Voor het maken van de clusters moet er eerst bekeken worden wat de ruimte moet zijn tussen de verschillende cellen

```{r clusteren van de genen, message=FALSE, warning=FALSE, echo=FALSE}
# de findneighbors functie berekend de ruimte tussen de verschillende cellen aan de hand van de PCA waardes. in dit geval worden de eerste 10 PC's mee genomen die zijn bij "dimentie bepalen van de dataset" bepaald.
pbmc <- FindNeighbors(pbmc, dims = 1:10)
# de functie Findclusters wordt gebruikt voor het vinden van de clusters. Bij een dataset van ongeveer 3000 cellen wordt de parameter rond de 0,4-1,2 gezet. Bij meer cellen wordt de waarde meer. 
pbmc <- FindClusters(pbmc, resolution = 0.5)

# hierna kunnen de clusters weergeven worden in een Umap. Hier worden weer de eerste 10 PCA's gebruikt. 
pbmc <- RunUMAP(pbmc, dims = 1:10)
DimPlot(pbmc, reduction = "umap")
# wanneer je de output wilt opslaan kan dat door de volgende code te gebruiken: saveRDS(pbmc, file = "../output/pbmc_tutorial.rds")
```

Nu de data uitgezet is in clusters kan er ook gekeken worden of de verschillende clusters ook unieke biomarkers hebben. 

```{r vinden cluster biomarkers, message=FALSE, eval=FALSE, echo=FALSE, warning=FALSE}
# door ident.1 = 2 aan te geven, worden alleen de biomarkers van cluster 2 weergeven.
cluster2.markers <- FindMarkers(pbmc, ident.1 = 2)

# alle markers die cluster 5 uniek maken van cluster 0 en 3.
cluster5.markers <- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3))
head(cluster5.markers, n = 5)
# het vinden van alle markers van alle clusters, maar alleen de positieve.
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)
pbmc.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1)
```

De unike biomarkers kunnen op verschillende manieren weergegeven worden. Een manier is met een VlnPlot. Hierin kan je zelf aangeven welke genen je wilt bekijken en wordt er weergeven in welke clusters het gen tot expressie komt. 

```{r visualiseren van de cluster markers, warning=FALSE, message=FALSE, eval=TRUE, echo=FALSE}
cluster0.markers <- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
head(cluster0.markers, 5)

# een plot om te weergeven waar het gen tot expressie komt.
VlnPlot(pbmc, features = c("MS4A1", "CD79A"))
```

Een andere manier is met een FeaturePlot. Dit is een plot om te weergeven welke features waar in de clusters zitten. Dit wordt gevisualiseerd door middenl van een FeaturePlot. 

```{r visualiseren in featureplot, warning=FALSE, message=FALSE, eval=TRUE, echo=FALSE}
# plot om te weergeven welke features waar in de clusters te voorschijn komen
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP",
    "CD8A"))
```
