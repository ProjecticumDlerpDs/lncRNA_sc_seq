---
title: "seurat_tutorial"
output: html_document
date: "2025-09-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## seurat tutorial
Voor het project gaan we analyses uitvoeren met Seurat. Om kennis te maken met het progamma wordt er een [tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial) uitgevoerd van Seurat.

```{r loading the library, include=FALSE}
#laad de volgende pakketen in. 
library(dplyr)
library(Seurat)
library(patchwork)
```

```{r loading dataset, include=FALSE}
# data inladen als een object. 
pbmc.data <- Read10X(data.dir = "~/lncRNA_sc_splice/raw_data/hg19/")
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```

```{r pre-procesing, warning=FALSE, results='hide', echo=TRUE}
# extra collum aanmaken waar het pecentage mitochondriaal RNA berekend wordt. cellen die lage kwaliteit hebben vertonen vaak een hoog percentage mitochondriaal RNA. extra colom wordt gemaakt met [[]]

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
head(pbmc, 5)

# visulaiseren van de data. dit kan gedaan worden in een violin plot. ncol staat voor de nummer van collomen. 
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)


# met een featurescatter kan er gevisulaiseerd worden wat de relatie is tussen verschillende features.
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1
plot2

# de cellen worden gefilterd op feature count van meer dan 2500 of minder dan 200. Er word ook gefilterd op minder dan 5% mitochondriaal pecentage
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
head(pbmc, 5)
```

```{r normaliseren van de data}
cat("het normaliseren van de data wordt gedaan door middel van de log methode. deze functie staat standaard op 10.000 ingesteld")

pbmc <- NormalizeData(pbmc)
head(pbmc, 5)
```
De data moet geselecteerd worden op genen die de meeste variabiliteit tonen. Dit zorgt ervoor dat bij verdere analyses er gefocused wordt op genen die variabel van elkaar zijn. Deze functie staat standaard ingesteld op 2000 features per dataset. 
```{r feature selectie van de data, warning=FALSE}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1
plot2
```
De functie zorgt ervoor dat de data vergelijkbaar wordt op de schaal en het gemiddelde. Dit zorgt ervoor dat de data beter verwerkt wordt bij verdere analyse zoals bij de PCA.

```{r scaling van de data}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```
bij een PCA analyse wordt de grote hoeveelheid data vereenvoudigt. De data kan ook in grafieken worden weergeven voor een vergemakkelijkeren weergaven. 
```{r PCA, message=FALSE}
# bij de eerste stap maakt Seurat een lijst voor de meest positieve en negatieve genen ten opzichte van de rest van de dataset. 
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))

# printen van de eerste 5 PC met elk 5 features.
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
# het visulaizeren van 2D. 
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
# dimplot is een plot waar alle puntjes cellen zijn. PC1 en PC2 zijn tegenover elkaar uitgezet. 
DimPlot(pbmc, reduction = "pca") + NoLegend()
# heatmap wordt gebruikt om te kijken welke onderdelen de grootste variatie van elkaar hebben. 
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)

```
clusters worden gebaseerd op de PCA waardes. Dit zijn correlaties tussen cellen die kwa genexpressie op elkaar lijken. om te bepalen hoeveel van de PCs's we mee nemen wordt er de onderstaande test uitgevoerd. 
```{r dimentie bepalen van dataset}
# elbowplot laat de verschillende dimenties zien. Hiermee kan je kiezen hoeveel dimenties je mee wilt nemen voor volgende analyses. 
ElbowPlot(pbmc)
# aan de hand van de grafiek worden de eerste 10 PC's mee genomen. 
```
De data moet worden geclusterd. Voor het maken van de clusters moet er eerst bekeken worden wat de ruimte moet zijn tussen de verschillende cellen
```{r clusteren van de genen, message=FALSE, warning=FALSE}
# de findneighbors functie berekend de ruimte tussen de verschillende cellen aan de hand van de PCA waardes. in dit geval worden de eerste 10 PC's mee genomen die zijn bij "dimentie bepalen van de dataset" bepaald.
pbmc <- FindNeighbors(pbmc, dims = 1:10)
# de functie Findclusters wordt gebruikt voor het vinden van de clusters. Bij een dataset van ongeveer 3000 cellen wordt de parameter rond de 0,4-1,2 gezet. Bij meer cellen wordt de waarde meer. 
pbmc <- FindClusters(pbmc, resolution = 0.5)
# De idents functie is voor het vinden van de clusters
# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)
# hierna kunnen de clusters weergeven worden in een Umap. Hier worden weer de eerste 10 PCA's gebruikt. 
pbmc <- RunUMAP(pbmc, dims = 1:10)
DimPlot(pbmc, reduction = "umap")
# wanneer je de output wilt opslaan kan dat door de volgende code te gebruiken: saveRDS(pbmc, file = "../output/pbmc_tutorial.rds")
```

